Programátorská dokumentace k zápoètovému programu:
Spravedlivé hledání min
Program má oddìlenou grafickou èást a èást zodpovìdnou za správnı bìh hry. Druhá èást je umístìna v adresáøi service, ale její úplnì hlavní èástí je MinesweeperService (minesweeper-service.ts). Zmíním-li tak nìjakou funkci bez udání tøídy, pùjde vdy o tuto.
Nejprve krátce o grafickém rozhraní
Jako u kadé Angular aplikace, grafickou èást obstarává hlavnì app component. V našem pøípadì pouívá dvì další komponenty, timer a square, timer jsou dva èíselníky a square jsou samotná herní políèka. Kolik políèek hra má a co na nich má bıt zobrazeno však rozhoduje service, a proto se zde pomocí ngFor iteruje columnArrayí, ze které se berou samotná data pro políèka.
Myslím, e zazší popis grafické èásti není potøeba, protoe zde není nic zvláš chytrého nebo záludného, ale jde prostì o pokus napodobit pùvodní hledání min. Všechny komponenty mají velikosti nastavené absolutnì v pixelech, co vìc mírnì usnadnilo (nebylo potøeba pracovat s relativními velikostmi pro rùzné displeje). Ještì zmíním, e veškeré ikony ve høe jsem kreslil v programu Inkscape.
Nyní u k implementaci 'spravedlnosti', resp. zjišování, která políèka jsou bezpeèná, která urèitì obsahují minu a která jsou nejistá, nazvìme to stavy políèek. Dále popsanı algoritmus je implementován metodou evaluate. Ta je z AppComponent vyvolávána po kadém stisknutí volného políèka (kromì tìch ukonèujících celou hru).
K problému se dá jistì pøistupovat rùznì. Nejsnazší pøístup by byl pouít omezené mnoství her, které by se støídaly a program by pøedem znal jejich vlastnosti. Popøípadì dokonce takovıch her, kde k nejednoznaènostem vùbec nedochází (pak by se vıbìr hry musel samozøejmì odvíjet od prvního tahu hráèe). Aèkoli takovı pøístup zní jako podvádìní, nebyl cizí ani originálním tvùrcùm min http://www.minesweeper.info/wiki/Windows_Minesweeper#Basic_Facts. Já se touto cestou ale nevydal a rozhodl jsem se problém øešit ve vší obecnosti a nechat hráèe taky zvolit rozmìry desky a poèet min. I tak je ale jistì stále spousta zpùsobù, jak problém øešit a je moné, e jsem nezvolil ten nechytøejší. Pojïme rozebrat, jak jsem došel k dnešní podobì algoritmu.
O samotném problému øešení minesweeperu se dá doèíst http://web.mat.bham.ac.uk/R.W.Kaye/minesw/ordmsw.htm, e je NP-úplnı. V této problematice si ještì úplnì nevìøím, tedy nechci tvrzení slepì vìøit, a taky je moné, e znalost skuteèného rozestavení (jako správce hry) problém redukuje na deterministicky polynomiální, ale a je to jakkoli, polynomiální øešení se mi najít nepodaøilo. Celı následující segment tak bude popisovat zpùsoby optimalizace algoritmu na pøijatelnì rychlı pøi praktickém uití.
Brute force
Nabízí se zaèít s myšlenkou zkrátka iterovat všemi rozestaveními min, ovìøit, která souhlasí s ji zobrazenımi èísly a u souhlasících ukládat pro kadé políèko poèty pøípadù, ve kterıch se na políèku mina nacházela. Pokud to nebude ádnı pøípad, políèko je bezpeèné, pokud všechny, na políèku urèitì mina je. Je to samozøejmì velmi hloupı postup, ale bude se od nìj odvíjet finální algorimus.
Narazili jsme taky na to, e se hodí vìdìt, která èísla u jsou na desce odhalena, resp. obecnì se bude hodit nìjaká datová struktura pro ukládání seznamù políèek. Vyadujeme od ní funkce vkládání, odebírání podle indexu a získání podle indexu. Úèel splní tøída MSList, není komplikovaná, obsahuje pouze dvì (nafukovací) pole s x-ovımi a y-ovımi souøadnicemi a informaci o délce seznamu. Odstranìní na indexu provedeme èistì vloením posledního prvku na danı index a sníením uloené délky. Zmìna poøadí po odstranìní prvku nám toti nebude vadit.
Struktura je mimochodem pouita u pøi náhodném rozmisování min (metoda setBombsRandomly), kde vloíme všechna políèka do MSListu, a postupnì vybíráme náhodné indexy, kde budou miny a ty ze seznamu odstraòujeme.
'Nasycená' èísla a dìlení na 'komponenty'
Testovat úplnì všechna políèka na monosti vıskytu min po kadém stisknutí je samozøejmì nesmysl, a u proto, e stavy nìkterıch políèek u známe z døívìjších bìhù algoritmu, nebo proto, e jsou mimo zobrazená èísla a jejich stavy zkrátka nelze urèit.
 V MinesweeperService najdeme MSList 'numList', kterı uchovává zobrazená èísla. První, co udìláme je, e èísly proiterujeme a zjistíme, zda neobsahují právì tolik políèek s potenciálními minami, jakou ukazují hodnotu, nebo jestli naopak není právì tolik políèek s jistou minou. V obou pøípadech mùeme èíslo nazvat 'nasycenım', odpovídajícím zpùsobem nastavit stavy okolních políèek, a èíslo odstranit z numListu. Tento proces zajišuje metoda eliminateCertain a iteruje se v ní numListem tak dlouho, dokud se dají najít nasycená èísla, tím se toti nasycenımi mohou stávat i další políèka. Tato èást je ještì polynomiální, protoe i kdybychom kadou iterací 'eliminovali' pouze jedno èíslo v numListu, celkem dojde k theta(n^2) vıpoètùm (n znaèí délku numListu), ale èistì z praktického zkoušení algoritmu je vidìt, e tento jednoduchı postup zejména u her s menší hustotou min odhalí stavy spousty, nìkdy i všech, políèek.
Pokud numList neskonèil prázdnı, mùeme si všimnout, e nìkterá políèka vzájemnì neovlivòují svoje stavy. Mùeme tedy zbylá èísla a jejich pøilehlá volná políèka rozdìlit na více celkù, øíkejme jim 'komponenty'. Volnım políèkùm ve zdrojovıch kódech øíkám 'idle'. Komponenty nalezneme speciálním prohledáváním, kde støídáme èíselná a idle políèka. To e spolu dvì èísla sousedí toti ještì neznamená, e jsou ve stejné komponentì. Toté platí i pro idle políèka. Na následujícím obrázku vidíme dva pøíklady rozdìlení na komponenty. Levá èást ukazuje dvì rùzné komponenty se sousedícími èísly, pravá naopak nesousedící idle políèka sdílející komponentu díky dvojce, která je spojuje (oba pøípady by u vyøešila samotná eliminace, teï ale šlo èistì o lepší pøedvedení konceptu komponent).
-obr1-prog.png-
O rozdìlení na komponenty se stará metoda divideIntoComponents, která zvláš ukládá èísla a idle pole komponent do componentNums a componentIdles, tj. k-tı index v componentNums obsahuje èíselná pole k-té komponenty v podobì MSListu a k-tı index component Idles podobnì její idle pole.
To u nám umoòuje pouít ji popsanı brute force algoritmus zvláš na všechny komponenty. Má to ale háèek. U pùvodního brute force jsme mohli jednoduše iterovat všemi rozestaveními uivatelem zvoleného poètu min. U komponenty ale pøedem nevíme, kolik min bude obsahovat, dokonce mùe mít více platnıch rozestavení s rùznımi poèty min. Napø. na následujícím obrázku vidíme komponentu, která mùe obsahovat jakıkoli poèet min mezi jednou a ètyømi.
-obr2-prog.png-
Všimnìme si tak, e metoda evaluateSimple s tím poèítá. Jakmile v nìjakém rozestavení min jsou èísla, která nemají okolo dost min, pøièem ostatní mají akorát, zkusí se i o jedna vyšší poèet min. Symetricky se mùe zkoušet i niší poèet min. To, e se tak dojde ke všem 'legálním' (odpovídajícím zobrazenım èíslùm) rozestavením dané komponenty je triviální, protoe se vdy zkouší všechna moná rozestavení min daného poètu, tedy i ty, které odpovídají legálním rozestavením s odebranımi, resp. pøidanımi minami.
S jakım poètem min ale zaèít? Nevadilo by zaèít jakımkoli èíslem od nuly (komponenta skuteènì nemusí mít ádné miny, jak pozdìji uvidíme) do poètu idle polí komponenty. My ale koneènì vyuijeme fakt, e známe skuteènı poèet min v komponentì, spoèítáme je a na této hodnotì zaèneme. Ještì se nabízí otázka, proè rovnou nezkusit všech 2^n (n je poèet idle polí komponenty) rozestavení min, èím si asymptoticky nepohoršíme. Vzhledem k tomu, e se ale dá èekat malı rozsah legálních poètù komponent, jde stále o vítané urychlení.
Postup je neúplnı
Bohuel, souèasnı postup není dostateènı .
1) Pokud napø. máme poslední dvì komponenty, zbıvá-li otestovat posledních 5 min, první komponenta mùe mít mezi dvìma a ètyømi minami a druhá má urèitì právì tøi miny, znamená to, e první komponenta má právì dvì miny a rozestavení o tøech a ètyøech minách nesmíme brát v úvahu.
2) Mùe se stát, e všechna idle políèka mimo komponenty buï jistì obsahují miny, nebo jsou urèitì bezpeèná, v závislosti na tom, kolik políèek u má zjištìné stavy
První problém se nejsnáze vyøeší tak, e v podobnıch pøípadech pøejdeme k pùvodnímu brute force postupu a všechny zbylá èísla i idle políèka bereme jako jednu velkou komponentu. Vydejme se ale jinou cestou. Legální rozestavení v komponentách nemusíme rovnou pøevádìt na stavy, ale mùeme si je uloit a vyuít pozdìji, konkrétnì v metodì setStates, kde se pouívají prefixové souèty minim a maxim min v komponentách k zjištìní limitù poètu min v komponentách. K ukládání tìchto informací pouijeme abstraktní tøídu EvaluationData. Jediné, co od ní oèekáváme, je znát rozmezí legálních poètù min komponenty a funkce pro získání samotnıch stavù (resp. celkového poètu legálních rozestavení a ke kadému poli poèet legálních rozestavení s minou v tomto poli) pro zadané rozmezí poètu min. To se bude pozdìji hodit i k pøesouvání bomb pro kıenou 'spravedlnost'. Druhı popsanı problém je jednodušší a je vyøešen v posledních dvou øádcích setStates. 
Implementaci EvaluationData pro zatím popsanı algoritmus najdeme v EvaluationDataSimple. Poøád nás ale trápí exponenciální rùst binomickıch koeficientù. Zkušenost konkrétnì na mém zaøízení øíká, e øádovì desetitisíce vıpoètù provedené prohlíeèem trvají nepostøehnutelnì krátkou dobu a statisíce znát, i kdy ještì netrvají nepøijatelnì dlouho. U 23 nad 11 je ale øádem v milionech a i kdy tak velké komponenty nejspíš nebudou úplnì bìné, musíme na nì bıt pøipraveni. Od toho je tu následující optimalizace.
Subkomponenty
Podívejme se teï na pozorování, které nám prozradí, e i komponenty se dají rozdìlit na menší èásteènì nezávislé celky. Propùjèíme-li si k tomu ukázku z citované stránky o NP-úplnosti min, mùeme si všimnout, e komponenta jde dodateènì rozdìlit na subkomponenty tak, e ádné èíslo nesousedí naráz s idle polem dvou rùznıch subkomponent. Konkrétnì na následujícím obrázku vidíme zelenì vyznaèenou jednu subkomponentu a oranovì druhou. Èísla taky jednoznaènì pøipadají jedné èi druhé komponentì podle toho, se kterou barvou sousedí. Navíc ale potøebujeme ještì èervená pole, která sousedí s èísly obou subkomponent. Ve zdrojovıch kódech taková pole oznaèuji jako 'mostová'.
-obr-prog.png-
Jak nám toto rozdìlení pomùe? Pokud bychom komponentu zpracovali pùvodním zpùsobem, testovali bychom (20 nad 8), tzn. 125'970 rozloení min. Po rozdìlení ale mùeme nejprve pro všechna rozloení min v mostovıch polích zpracovat obì subkomponenty jako standardní komponenty a poté, opìt pro kadé rozloení v mostech, zaznamenat jen ty 'legální'. To znamená (dvì komponenty, 8 idle polí komponenty - maximální binomickı koeficient, 4 mostová pole) zhruba 2 * (8 nad 4) * 2^4 = 2'240 (zanedbávám pøípadné zkoušení rùznıch poètù min v subkomponentách), tedy posunuli jsme se ze stovek tisíc vıpoètù na tisíce.
Nìjakı èas ale zabere i rozdìlení na subkomponenty. Rozklad grafù by si nejspíš zaslouil vlastní zápoètovou práci, nebo i víc ne to, já jsem se ale rozhodl pro následující jednoduchı algoritmus. Pøednì, 'malé' komponenty vùbec rozkládat nebudeme (nech to jsou komponenty o ménì ne jedenácti idle poli). Mìjme uloena èíselná pole subkomponent, tj. ze zaèátku prázdné pole MSListù. Nyní iterujme èíselnımi poli pùvodní komponenty. Iterace bude probíhat takto: je-li souèasné pole ji souèástí -dostateènì velké- subkomponenty, nedìlej nic. Je-li ale subkomponenta -malá- pøidej do ní taky sousední èísla (sousednost skrze idle pole). Pokud souèasné pole není souèástí subkomponenty, vytvoøí se nová subkomponenta a vloí se do ní souèasné pole a všechny sousední pole. Nech subkomponenta je '-malá-', pokud má ménì ne (poèet èíselnıch*5/poèet idle + 1) (heuristicky nastavená velikost).
Tím jsme získali nìkolik seznamù èíselnıch polí, ze kterıch se dají odvodit i idle pole subkomponent. Mohlo však dojít k následujícím neádoucím jevùm:
-nìkteré subkomponenty by takto nemìly vlastní idle pole
-máme pouze jedinou subkomponentu
V prvním pøípadì takové subkomponenty pøipojíme k nìkterım sousedním (stále mùe dojít ke druhému problému)
V druhém pøípadì pøistupujeme ke kadému èíslu komponenty jako ke zvláštní subkomponentì a opravíme pøípadnı vıskyt prvního problému.
Pokud i tak stále máme jedinou subkomponentu, rozklad jednoduše vzdáme (pøedpokládám, e tento jev bude vzácnı).
Stejné komponenty dokola
Mùe bıt iritující, e popsanı  postup provádíme po zcela kadém hráèovì tahu. Nìkteré komponenty pravdìpodobnì evaluujeme vícekrát dokola. Všimnìme si však, e typicky evaluace pøináší nìkolik polí s jistım stavem, co samotnou komponentu mìní (u nejde o stejnou komponentu) a i kliknutí samotná komponenty mìní. Ovìøování opìtovného vıskytu stejnıch komponent by sice bylo polynomiální, to ale v praxi nemusí moc znamenat, vzhledem k tomu, e je vıbìr pole pøeci jen omezeno. Rozhodl jsem se tak obìtovat potenciální mírné zrychlení nìkterıch pøípadù na úkor jinıch a tuto 'optimalizaci' vùbec neimplementovat.
Pøesouvání min a spravedlnost
Stavy polí u zjistit umíme. Teï naimplementujme samotnou spravedlnost. Popíšu pouze 'mazání' miny z nejistého pole pøi ádnıch bezpeènıch polích, Pøípad pøidávání miny je symetrickı.
Samozøejmì se budeme zabıvat jen ovlivnìnou komponentou, tedy po stisknutí pole s minou minu odstraníme a budeme pøedstírat, e jde o prázdné pole, pøièem prohledáme okolí pro jednotnou komponentu, na které budeme operovat. Pro jednoduchost (a zamezení zbyteènému zpomalení programu) nebudeme nastavovat ádná omezení pro poèty min v komponentì. Dále u je pøesouvání min analogické samotnému algoritmu pro zjišování stavu polí v komponentì. Jednoduše se zjistí celkovı poèet monıch rozloení min a vybere se z nich náhodné. Pøi tom se samozøejmì mùe zmìnit celkovı poèet min v poli, co vykompenzujeme èistì políèky mimo všechny komponenty. To sice staèit nemusí, potøebovali bychom mìnit poèty min i v ostatních komponentách, ale to by hru zbyteènì zpomalilo, proto jsem se rozhodl ponechat nepatrnou monost celkové zmìny min v poli, která se projeví na levém èíselníku.
Vıbìr náhodného rozloení min je samozøejmì sloitìjší u kompozitních komponent. Pro urèité rozloení min v mostech je celkovı poèet legálních rozloení souèin poètù moností v subkomponentách. O vıbìr správnıch rozloení v nich máme metodu getSubiterations, která de facto vybrané poøadí rozloení pøevede na èíslo o tolika cifrách, kolik je subkomponent, kde kadá cifra má váhu podle poètu legálních rozloení min v pøíslušné subkomponentì (co odpovídá zvolenému rozloení min).
Závìrem
Zdá se, e program je teï relativnì dost rychlı pro rùzné rozmìry herního pole i pro naschvál nešikovnì zvolená stisknutá pole. Myslím, e graficky je hra relativnì vìrnou imitací Windows Minesweeperu. Pokud se vám na høe, její implementaci nebo stylu mého kódu cokoli nelíbí, dejte mi prosím vìdìt. Jakákoli zpìtná vazba se hodí. Pokud chcete algoritmus lépe pozorovat pøi práci, v nastavení hry je pøístupná monost zobrazovat stavy polí a mùete si tak hru nechat vyøešit za sebe.
